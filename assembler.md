# Программирование на языке Ассемблера

_Василий Борисович из политеха_

## Тема 1: Общие понятия языка Ассемблера

**Assembler** - низкоуровневый язык программирования, максимально приближенный к программированию на машинном коде

- delay(32) -> { ... }

Для написания на языке ассемблера необходимо знать архитектуру программной части процессора

Архитектура программной части:
1. Структурная и функциональная схема в целом
2. Организация оперативной памяти
3. Строение внешний устройств (и форматы регистров)
4. Организация и функционирование процессора, способы адресации, система команд
5. Система прерыван_их состоит из частей частей, одна их которых - АЛУ_

Строение процессора:
- АЛУ - _Чё-то там каких-то "ичных операций"_ Арифметически-Логичное Устройство
- ПД (Память данных)
- ПК (Память команд)

- Intel
- AVR
- PIC

- 16Fxx33
- 18Fxx33

- Atmega 8, 16, 32

Для написания ... нужно знать ... структуру... нужно знать, что происходит в данной ...

- Atmega 32$

Программирование на ассемблеревишут в следующих случаях:
- Когда важно оптимизировать размер кода и объем используемой памяти
- Быстродействие

- 256к
- 16

Arduino поддерживает программирование как на урезанной версии языка C, так и на ассебмлере.


- [Д] - [М] - [Н]

- **Д**анные
- **М**икропроцессор
- **Н**

Чтобы написать программу, нужно знать её алгоритм.
Во время раблты происходит нагрев, для охлаждения используют радиаторы для улучшения теплоотделения, так же могут ставить куллер, перегоняющий холодный воздух на радиатор.

IDE для Arduino:
- Arduino IDE (Arduino)
- Atmel Studio (Atmega) - Для профессионального написания программ на Assembler и C

IDE для написания под PIC контроллеры (самые популярные в 2000-е годы):
- MPLab

STxx - 8 грн/шт

Бит:
- < 2.5В - 0
- >= 2.5В - 1

Все внешние устройства имеют свой адрес в оперативной памяти, с помощью которого процессор может обращаться к этому устройству.

Память 256Мб

2 архитектуры разметки памяти микропроцессора:
- В документации процессора расписано, какая область памяти под что размечена
- Разделение всей памяти на 2 части:
  - Для данных
  - Для команд


# Тема #2: Структура программы на языке Assembler

Любая программа, написанная на ассемблере, состоит из одного или нескольких сегментов.

> **Сегмент** - это область памяти, которая занята командами или данными, адреса которых вычисляются относительно соответствующего сегментного регистра.

Область памяти, содержащая команды называется **сегментом кода**, с данными — **сегмент данных**.
Так же, некоторая область отведена под Stack — **сегмент стека**.

> **Стек** - область памяти для временного хранения произвольных данных.

Для переключения считывания кода программы с внешнего устройства достаточно записать определённое значение в нужный регистр.

```
[Клав.]  [Прогр]  [Микропроц.]  [Внешн. устр.]
   |        |         | | |            |
----------------------|-|-|------------------- (wА) - Шина аппарат-чё-то-там
----------------------|-|-|------------------- (wД) - Шина данных
----------------------|-|-|------------------- (wУ) - Шина управления
                        |
                       <->
```

Адресные системы:
- Младшая
- Старшая

Решают, какое из устройств будет использоваться (напр. внутренняя/внешняя видеокарта).
Управляются старшим битом.

# Тема #3: Пересылка данных

Нужно знать:
- Центральный процессор
- Регистры - Все внутренние регистры микропроцессоров делятся на:
  - Регистры данных - Нужны для временного хранения переменных и результатов различных операций над ними.
    - AX - Аккумулятор. В нём хранится один из операндов перед выполнением некоторой операции, и куда попадает результат выполнения этой операции.
    - BX - Базовый. Используется для формирования адреса переменных в памяти.
    - CX - Счётчик. Служит счётчиком в цикле.
    - DX - Дополнительные данные. Хранит старшие разряды результата, который не поместился в аккумулятор.
    - Могут быть разбиты на 2 однобайтных регистра: AH, AL
  - Регистры индексов - Используют или для формирования адресов переменных, или как регистры хранения временных переменных. (2 байта, нельзя разделить)
    - BP - Указатель базы
    - SI - Индекс источника
    - DI - Индекс приёмника
    - SP - Указатель стека - Используют в командах передачи управления.
  - Сегментные регистры
    - CS - Регистр сегмента команд (Сегмент кода программы) - Используется для вычисления адреса следующей команды программы из регистра указания команд.
    - SS - Регистр сегмента стека - Используется для определения адреса области памяти для хранения временных данных.
    - DS - Регистр сегмента данных - Используется для хранения переменных, используемых в программе.
    - ES - Регистр сегмента дополнительных данных - Используется при операции над строками.
  - Регистры флагов - Используются для получения состояния микропроцессора (0/1):
    - CF - Флаг переноса
    - PF - Флаг парности
    - AF - Флаг дополнительного переноса
    - ZF - Флаг нуля
    - SF - Флаг знака
    - TF - Флаг трассировки (используется при отладке)
    - IF - Флаг прерывания (можно ли прервать выполнение)
    - DF - Флаг направления (строки)
    - OF - Флаг переполнения (индикатор работы с знаковыми числами)
- Организация памяти в компьютере
- Организация стека
- Организация памяти

### 3.1: Команды пересылки данных

- MOV
- MOVZX
- MOvSX

> Команды пересылки используются для пересылки (копирования) данных из источника (Source) в ячейку-получателя (Destination).

Содержимое получателя теряется, а содержимое источника не изменяется.

Можно использовать:
- В качестве получателя:
  - Регистр
  - Переменная в памяти
- В качестве источника:
  - + Константа (записанная как часть команды)

Необходимо отслеживать, чтобы размерность (типы) пересылаемых переменных совпадали.

Но если нужно, можно использовать расширенные команды пересылки (MOVZX, MOVSX).

Общая форма записи команды пересылки:
- `MOV <destination>, <source>`

Существуют 7 вариантов команды MOV:
- `MOV AX, BX` - Перемещение регистров AX = BX
- `MOV CX, EXWORD` - CX = Память
  - EXWORD - Константа
- `MOV SI, 1000` - SI = 0b1000

#### Команда обмена XCHG

> Меняет местами значения.

- `XCHG BX, CX` - BX <-> CX
- `XCHG BX, EXWORD`

### 3.2: Оператор определённого типа
### 3.3: Команды работы со стеком

- PUSH <value> - Запись в стек
- POP <destination> - Считать со стека

Основное предназначение стека - временное хранение данных.

### 3.4: Ввод и вывод информации
### 3.5: Арифметические операции

Существуют команды для выполнения всех стандартных арифметических действий для всех типов данных.
- +
  - ADD <destination>, <source>: <destionation> += <source>
    - typeof(<destionatin>) in [\_X]
  - ADC <destionation>, <source>: - Сложение, когда результат не помещается в <destination> - в качестве дополнительного бита переполнения используют CF (флаг)
    - <destination> += <source> + CF
  - INC <destination>: <destination>++
- -
  - SUB <destination>, <source>: <destination> -= <source>
  - SBB <destination>, <source>: <destination> -= <source> - CF
  - DEC <destination>: <destination>--
- \*: Второй аргумент должен находиться в регистре AL
  - AX:
    - AH
    - AL <- второй множитель
  - MUL <value>: - Умножение unsigned int
    - MUL B1: AX \*= B1
  - IMUL <value>: - Умножение signed int
- /
  - DIV
  - IDIV - Деление signed int
- NEG - Инвертирование знака

### 3.6: Порозрядные операции (Побитовые операции)

Группа специальных команд, предназначенных для работы с битами:
- BT - Проверка бита
- BTC - Проверка бита с инвертацией
- BTR - Проверка бита с обнулением
- BTS - Проверка бита с заданием 1
- BSF - Сканировать битовое представление (->) (Поиск единицы)
- BSR - Сканировать битовое представление (<-)

### 3.7: Логические команды

- AND - Логическое произведение
- OR - Логическая сумма
- XOR - Умножение по модулю 2
- NOT - Инвертирование

```
386 ; Версия процессора, под который создаётся программа

```

### 3.8 Этапы строения программы

1. Ввод первичного текста
2. Трансляция (.asm) -> .obj + .lst
3. Компоновка .obj -> .exe
4. Отладка

### 3.9 Структура программы

> [метка]  [команда/директива]  [опер,анды]  [; комментарий]

> Команда - Отображение машинного кода

> Директива - Параметры для транслятора

Важные директивы ассемблера:
- Директивы определения данных (объявление типов данных):
  - Общий вид: `<varname> <directive>, <value>`
    - Вместо <value> можно указывать ? для оставления предыдущего значения
  - db - BYTE (8)
  - dw - WORD (16)
  - dd - DWORD (32)
  - df - (48)
  - dq - (64)
  - dt - (80)
  - > Можно использовать повторение: **DUP**
    - `db 0, 0, 0, 0, 0, 0, 0, 0` -> `db 8dup(0)`
    - `dw 100DUP(?)` = `int16[100]`
    - `db 3dup('abc', ?, 6)
- Директива эквивалентности **EQU** (аналог #define в C):
  - Общий вид: `<name> EQU <operator>`
  - R EQUi AX
  - Message EQU 'Hello World'
- Директива присваивания **=**:
  - `x = 1`
- Директива задания набора допустимых команд
  - .8086
  - .686 (Pentium 2)
  - .MMX (IA MM)
- Директивы определения сегмента:
  - .data - Определяет начало/продолжение сегмента данных
  - .const - Определяет сегмент констант (директив)
  - .stack - Определяет сегмент стека
  - .code - Определяет сегмент кода
- Директива указания модели памяти (.model):
  - Должна находиться внутри любой директиве определения сегментов
  - `.model <model> [, <lang>] [, <modifier>]`
  - <model>:
    - TINY - Один сегмент памяти, размером <= 64 кб (резмещают коды, данные и стек)
    - SMALL - Может иметь до трёх сегментов (1\*64 сегмент для кода, 1 для данных и 1 для стека)
    - COMPACT - Аналогично SMALL, но может иметь несколько сегментов данных
    - MEDIUM - Аналогично SMALL, но может иметь несколько сегментов для кода
    - LARGE - Аналогично COMPACT + MEDIUM, но может иметь несколько сегментов для стека
    - HUGE - Запрещается использование данных < 64 кб, реализуется только в защищённом режиме
    - FLAT - Вся память как единый сегмент для кода, данных и стека размером 4 Гб
  - <lang> (Служит для связи с языками высокого уровня):
    - C
    - PASCAL
    - BASIC
  - <modifier>:
    - NEARSTACK - Размещается в одном физическом сегменте памяти
    - FARSTACK - Размещается в разных сегментах памяти

#### Программа типа COM

```
.model tiny
.code
crg 100h ; Освобождение первых 256 байт при загрузке файла в память
start   mov ah, 9 ; Номер функции для вывода информации на экран?
        mov dx, offset message
        int 21h
        ret

message db "Hello, World", oof, oah, "$"
    end start

```

Различие COM и EXE:
- COM - Может сразу выполняться (DOS загружает файл в память и передаёт управление в сегмент команд с отступом 100H)
  - Макс размер: 64 Кб
- EXE - Сначала считывается информация генератора связей из заголовка EXE файла

Программа сложения содержимого двух 8-битных ячеек в сегменте данных DS 0x1000 и DS 0x1001

```
MOV AL, [1000H]
ADD AL, [1001H]
MOV [1002], AL
END
```

Для платформы x86 написать программу вычисления функции 0d42 = (z=AX, y=0d41) => z - y

```
MOV CL, [0041]
MOV CH, 00
SUB AX, CX
MOV [0042], AH
MOV [0043], AL
```

Передать число с первой ячейки нулевого сегмента во вторую ячейку третьего

```
MOV AX, 000H ; Передача номера сегмента
MOV DS, AX ; Указание номера сегмента, с которым имеем дело

MOV BX, [0001]

MOV AX, 0003h
MOV DS, AX

MOV [0002], BX
```

`int z = int x + int y` с использованием директив

```
.model small

.data ; namespace data {

x dw 5 ; short x = 5
y dw 3 ; short y = 3
z dw ? ; short z

; }
.code ; namespace code {

begin:  MOV AX, @data ; using namespace data
        MOV DS, AX

        MOV AX, X ; $AX = x
        ADD AX, Y ; $AX += y
        MOV Z, AX ; z = $AX

        MOV AX, 4C00H ; $AX = [0x4C *return*, 0x00] 
        INT 21H ; $AX[0]($AX[1])
        END begin
; }
```

`int z = int x + int y` с использованием процедур и директив MOSM32

```
.386

.model flat, stcall

.data ; namespace data {

; }

.code ; namespace code {

start:  MOV AX, 5
        MOV BX, 3
        call AddPr ; stack =  goto AddPr => ... => goto stack
        ret

    AddPr proc
        ADD AX, AB
        ret
    ArrPr ENDDP
END start

; }
```
